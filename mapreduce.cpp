#include "mapreduce.hpp"

using namespace mapreduce;

void Framework::run(const std::filesystem::__cxx11::path &input, const std::filesystem::__cxx11::path &output)
{
    auto blocks = split_file(input, mappers_count);

    // Создаём mappers_count потоков
    // В каждом потоке читаем свой блок данных
    // Применяем к строкам данных функцию mapper
    // Сортируем результат каждого потока
    // Результат сохраняется в файловую систему (представляем, что это большие данные)
    // Каждый поток сохраняет результат в свой файл (представляем, что потоки выполняются на разных узлах)


    // Создаём reducers_count новых файлов
    // Из mappers_count файлов читаем данные (результат фазы map) и перекладываем в reducers_count (вход фазы reduce)
    // Перекладываем так, чтобы:
    //     * данные были отсортированы
    //     * одинаковые ключи оказывались в одном файле, чтобы одинаковые ключи попали на один редьюсер
    //     * файлы примерно одинакового размера, чтобы редьюсеры были загружены примерно равномерно
    //
    // Гуглить: алгоритмы во внешней памяти, external sorting, многопутевое слияние
    //
    // Для упрощения задачи делаем это в один поток
    // Но все данные в память одновременно не загружаем, читаем построчно и пишем
    //
    // Задание творческое!
    // Я не уверен, что все вышеперечисленные требования выполнимы одновременно
    // Возможно, придётся идти на компромисс, упрощая какие-то детали реализации
    // Но это то, к чему нужно стремиться
    // Проектирование ПО часто требует идти на компромиссы
    // Это как оптимизация функции многих переменных с доп. ограничениями


    // Создаём reducers_count потоков
    // В каждом потоке читаем свой файл (выход предыдущей фазы)
    // Применяем к строкам функцию reducer
    // Результат сохраняется в файловую систему
    //             (во многих задачах выход редьюсера - большие данные, хотя в нашей задаче можно написать функцию reduce так, чтобы выход не был большим)
}

std::vector<Framework::Block> Framework::split_file(const std::filesystem::__cxx11::path &file, int blocks_count)
{
    // Эта функция не читает весь файл.
    // Определяем размер файла в байтах.
    // Делим размер на количество блоков - получаем границы блоков.
    // Читаем данные только вблизи границ.
    // Выравниваем границы блоков по границам строк.
}
