#pragma once

#include <cstdint>
#include <vector>
#include <filesystem>
#include <functional>

namespace mapreduce
{

/// Это MapReduce фреймворк.
/// Он универсальный.
/// Он может выполнять разные map_reduce задачи.
/// Он просто обрабатывает какие-то данные с помощью каких-то функций в нескольких потоках.
/// Он ничего не знает о задаче, которую решает.
/// Здесь не должно быть кода, завязанного на конкретную задачу - определение длины префикса.
///
/// С помощью этого фреймворка должны решаться разные задачи.
/// Когда напишете это, попробуйте решить с помощью этого фреймворка все задачи, которые мы разбирали на лекции.
///
/// Это наш самописный аналог hadoop mapreduce.
/// Он на самом деле не работает с по-настоящему большими данными, потому что выполняется на одной машине.
/// Но мы делаем вид, что данных много, и представляем, что наши потоки - это процессы на разных узлах.
///
/// Ни один из потоков не должен полностью загружать свои данные в память или пробегаться по всем данным.
/// Каждый из потоков обрабатывает только свой блок.
///
/// На самом деле даже один блок данных не должен полностью грузиться в оперативку, а должен обрабатываться построчно.
/// Но в домашней работе можем этим пренебречь и загрузить один блок в память одним потоком.
///
/// Всё в этом файле - это рекомендация.
/// Если что-то будет слишком сложно реализовать, идите на компромисс, пренебрегайте чем-нибудь.
/// Лучше сделать что-нибудь, чем застрять на каком-нибудь моменте и не сделать ничего.
class Framework
{
public:
    void run(const std::filesystem::path& input, const std::filesystem::path& output);

private:
    struct Block
    {
        std::size_t from;
        std::size_t to;
    };

    std::vector<Block> split_file(const std::filesystem::path& file, int blocks_count);

    std::size_t mappers_count;
    std::size_t reducers_count;

    std::function</*type*/> mapper;
    std::function</*type*/> reducer;
};

}
